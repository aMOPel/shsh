#!/usr/bin/env sh
#, respectively.
# Summary: Installs a package from github (or a custom site)
#
# Usage: shsh install [site]/<package>[@ref] [<folder>/<folder>]
#                     [-h|--hook <hook>] [-v|--variable <VAR>=<VAL>] [--ssh]
#                     [--nocleanup] [-f|--force]
#
# Options:
#       -h, --hook <HOOK_TYPE>[=<CONTENT>]
#                    add HOOK to this package, which is triggered while 
#                    installing or upgrading a package
#       -v --variable <VAR>=<VAL>
#                    set a variable VAR with value VAL,
#                    useful for setting up files for linking 
#       --nocleanup  do not perform cleanup (shsh uninstall <package>)
#                    even if something failed in the installination process
#       -f, --force  force the installation even if the package exists
#       --ssh        use ssh protocal instead of https
#
#       --verbose    display more info for some commands
#
# Hook types:
#   pre=<SCRIPT>     Any arbitrary POSIX script that runs before linking.
#   post=<SCRIPT>    Any arbitrary POSIX script that runs after linking.
#   uninstall=<...>  Any arbitrary POSIX script that runs before uninstalling.
#                    For the above hooks, if multiples are given, the older
#                    one will be overriden.
#   +x=<FILE>        Before linking, adds executable bit to the FILE. If
#                    multiples are given, they will be run in sequential order.
#   a+x              Before linking, add executable bit to all files.
# 
# Examples:
#   shsh install soraxas/dot-reminder
#                    install 'soraxas/dot-reminder' as a package
#   shsh install soraxas/git-utils git/tools
#                    install 'soraxas/git-utils' to a folder within 'git/tools'
#   shsh install --ssh <package>
#                    install with ssh protocal (rather than https)
#   shsh install <package> -v FISH_COMPLETIONS=synoservice.fish:forgit.fish
#                    link 'synoservice.fish' and 'forgit.fish' as fish
#                    completion files
#   shsh install <package> --hook pre="mv bin/foo bin/bar"
#                    Execute the script "mv bin/foo bin/bar" before `shsh`
#                    performs linking (e.g. this script renames the binary)
#   shsh install <package> --hook +x=foobar
#                    add a hook that add executable bits to the file 'foobar',
#                    before linking is performed
#   shsh install <package> -h pre='make all' -h post='rm -r build/*'
#                    add a hook that runs 'make all' to build binaries, right
#                    after cloning and before linking is performed. Then, 
#                    linking is performed with its usual rules (i.e. all 
#                    executable files in root and in bin/). Finally, 
#                    'rm -r build/*' is ran to remove leftovers.


set -e

. "${UTILS_FUNC:?}"

original_args="$(requote_args "$@")"

use_ssh="false"

EOL=$(echo '\00\07\01\00')
if [ "$#" != 0 ]; then
  set -- "$@" "$EOL"
  while [ "$1" != "$EOL" ]; do
    opt="$1"; shift
    case "$opt" in
      --ssh)
        use_ssh="true"
        ;;
      --nocleanup)
        no_cleanup="true"
        ;;
      -f|--force)
        force_install="true"
        ;;
      -h|--hook)
        case "$1" in
          # pre|post|uninstall|+x)
          #   check_key_val_pair "$1" "$opt"
          #   ;;
          pre=*|post=*|uninstall=*)
            _hook_type="${1%%=*}"
            _hook_value="${1#*=}"
            eval "hook_$_hook_type='$_hook_value'"
            ;;
          +x=*)
            if [ -z "$hook_plus_x" ]; then
              hook_plus_x="${1#*=}"
            else
              hook_plus_x="$hook_plus_x:${1#*=}"
            fi
            ;;
          a+x)
            hook_all_plus_x=true
            ;;
          *)
            echo "Unrecognized hook type '$1'"
            exit 1
            ;;
        esac
        shift
        ;;
      -v|--variable)
        check_key_val_pair "$1" "$opt"
        _var="${1%%=*}"
        _val="${1#*=}"
        [ -z "$_var" ] && echo "Invalid argunment for '--variable' with '$1'" && exit 1
        eval "$_var='$_val'"
        export "$_var"
        shift ;;
      --*=*)  # convert '--name=arg' to '--name' 'arg'
        set -- "${opt%%=*}" "${opt#*=}" "$@";;                        
      -[^-]?*)  # convert '-abc' to '-a' '-b' '-c'
        set -- $(echo "${opt#-}" | sed 's/\(.\)/ -\1/g') "$@";;       
      --)  # process remaining arguments as positional
        while [ "$1" != "$EOL" ]; do set -- "$@" "$1"; shift; done;;  
      -*)
        echo "Error: Unsupported flag '$opt'" >&2
        exit 1
        ;;
      *)
        # set back any unused args
        set -- "$@" "$opt"
    esac
  done
  shift # remove the EOL token
fi


if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
  shsh-help install
  exit 1
fi

case "$1" in
  */*/*)
    IFS=/ read -r site user name <<EOF
$1
EOF
    ;;
  */*)
    IFS=/ read -r user name <<EOF
$1
EOF
    site="github.com"
    ;;
  *)
    shsh-help install
    exit 1
    ;;
esac
package="${user}/${name}"

# defaults to package's name, but allows custom folder name
folder="$package"
if [ -n "$2" ]; then
  case "$2" in
    */*)
      ;;
    *)
      # shsh-help install
      echo "Optional argunment [folder] must be in the format <...>/<...>, not '$2'"
      exit 1
      ;;
  esac
  folder="$2"
fi

if [ -z "$package" ]; then
  shsh-help install
  exit 1
fi

IFS=/ read -r user name <<EOF
$package
EOF

if [ -z "$user" ]; then
  shsh-help install
  exit 1
fi

if [ -z "$name" ]; then
  shsh-help install
  exit 1
fi

ref=""
case "$package" in
  */*@*)
    IFS=@ read -r package ref <<EOF
$package
EOF
    ;;
esac

if [ -z "$folder" ]; then
  folder="$package"
fi
target_folder="${SHSH_PACKAGES_PATH}/$folder"

on_exit () {
  [ $? -eq 0 ] && exit
  # non-zero exit status
  [ -n "$no_cleanup" ] && exit
  echo "> Error occured. Cleaning up..."
  export hook_uninstall
  shsh uninstall "$folder"
}
trap on_exit EXIT


## INSTALLING
[ -n "$force_install" ] && shsh uninstall "$folder" >/dev/null 2>&1 || true
# only perform link if clone is successful (and package not exists before)
if ! shsh-_clone "$use_ssh" "$site" "$package" "$ref" "$folder"; then
  exit
fi
shsh-_deps "$folder"

[ -n "$hook_plus_x" ] && execute_hooks "+x hook" "$target_folder" "IFS=:; for x in \$hook_plus_x; do chmod +x \"\$x\"; done"
[ -n "$hook_all_plus_x" ] && execute_hooks "a+x hook" "$target_folder" "chmod -R +x ."
[ -n "$hook_pre" ] && execute_hooks "pre-hook" "$target_folder" "$hook_pre"

## LINKING
shsh-_link-bins "$folder"
shsh-_link-man "$folder"
shsh-_link-completions "$folder"
[ -n "$hook_post" ] && execute_hooks "post-hook" "$target_folder" "$hook_post"


## SHSHRC
# add successfully installed package to shshrc
if [ -e "$SHSHRC" ]; then
  set +e  # allow non-zero exit status in pattern matching
  existing="$(grep -E "^\s*shsh install $1(\s.*)?$" "$SHSHRC")"
  # extract suffix if any (e.g. '&& \' or '|| \')
  _ending_pattern='\s+([&][&]|[|][|])\s*[\]\s*$'
  existing_suffix="$(echo "$existing" | grep -oE "$_ending_pattern")"
  # extract prefix if any (i.e. white spaces)
  existing_prefix="$(echo "$existing" | grep -oE "^\s*")"
  # remove these from the statement for comparison
  existing="$(echo "$existing" | sed -E "s/$_ending_pattern//; s/^(\s*)//")"
  new_statement="shsh install $original_args"

  if [ -z "$existing" ]; then
    # append the file with new package
    echo "> Appending statement to \$SHSHRC: \"$new_statement\""
    echo "$new_statement" >> "$SHSHRC"

  # check if existings are the same (e.g. with same flags etc.)
  elif [ "$existing" != "shsh install $original_args" ]; then
    # update the file with new args/flags
    new_statement="${existing_prefix}${new_statement}${existing_suffix}"
    # 1st sed pattern: escape '&' (in awk gsub it has the meaning of matched string)
    # 2nd sed pattern: all backslash needs to be doubled in awk
    new_statement="$(echo "$new_statement" | \
      sed 's/&/\\&/g; s/\\/\\\\/g')"
    
    echo "> Updating existing statement in \$SHSHRC to \"$new_statement\""
    cat "$SHSHRC" | awk '{gsub(old,new); print}' old="^[[:space:]]*shsh install $1([[:space:]].*)?$" \
      new="$new_statement" > "${SHSHRC}.tmp" && mv "${SHSHRC}.tmp" "${SHSHRC}"
  fi
  set -e
fi
