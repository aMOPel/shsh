#!/usr/bin/env sh
#
# Summary: A versatile shell scripts handler
#
# Usage: shsh <command> [<command args>] [--verbose] [--help]
#
# Options:
#       --help        display help message for any commands
#       --version     output version information and exit
#       --verbose     display more info for some commands
# 
# Examples:
#   shsh install user/repo    install 'user/repo' as a package
#   shsh list                 list all installed packages
#   shsh outdated             check against upstream on repos' status
#   shsh upgrade --all        upgrade all installed packages
#   shsh uninstall user/repo  uninstall the package 'user/repo'
#
# Environment:
# The following environment variables has effects in `shsh` of
# changing the default directories of stored files.
#
#   XDG_DATA_HOME       directory of shsh's root, i.e.
#                       SHSH_ROOT=$XDG_DATA_HOME/shsh
#                       [default: ~/.config]
#   SHSH_PREFIX         directory to store everything
#                       [default: $SHSH_ROOT/cellar]
#   SHSH_PACKAGES_PATH  directory to store packages
#                       [default: $SHSH_PREFIX/packages]
#   SHSH_INSTALL_BIN    directory to store bins
#                       [default: $SHSH_PREFIX/bin]
#   SHSH_INSTALL_MAN    directory to store mans
#                       [default: $SHSH_PREFIX/man]
#
# The following environment variables changes `shsh`'s linking
# behaviour by overriding/customising the list of files to be
# linked into cellar. They can be specified by 'package.sh' (see
# repository), or by the --variable flag in `shsh install`, or
# by running `shsh` with the following environmental variables.
# Note that all of the following variables can be a colon separated 
# list that follows the PATH variable convention, e.g. FOO:BAR
#
#   BINS                list of binary/script files to link
#                       [default: all executable files in root and bin/*]
#   MANS                list of man pages to link
#                       [default: all files in man/*.[0-9] and 
#                       man/man.[0-9]/*.[0-9]]
#   BASH_COMPLETIONS    list of bash shell completion files to link
#   ZSH_COMPLETIONS     list of zsh shell completion files to link
#   FISH_COMPLETIONS    list of fish shell completion files to link
#                       [default: all files in completions/*.fish and
#                       completions/fish/*.fish]
#
# Files:
# SHSHRC: The file `$XDG_CONFIG_HOME/shshrc` shall be an executable file 
# that store all installed packages. Whenever shsh install a package, it 
# will add the package to SHSHRC. If there is an existing entry, it will
# update that entry with the new flags/argunment instead. It will search
# for all lines within SHSHRC that begins with `shsh install`, ignoring
# all preceeding whitespace. For more details, visit project homepage.
#
# Report bugs to <oscar@tinyiu.com>, or https://github.com/soraxas/shsh

set -e

resolve_link() {
  if type greadlink >/dev/null 2>&1; then
    greadlink -f "$1"
  else
    if ! readlink -f "$1" 2>/dev/null; then
      # use self-implemented `readlink -f`
      readlink_canonicalise "$1"
    fi
  fi
}

readlink_canonicalise() (  # we are using subshell to prevent messing up cd
  # This is poor man's GNU `readlink -f`
  # useful for mac without GNU readlink
  # based on https://stackoverflow.com/questions/1055671/how-can-i-get-the-behavior-of-gnus-readlink-f-on-a-mac
  TARGET_FILE=$1
  cd `dirname $TARGET_FILE`
  TARGET_FILE=`basename $TARGET_FILE`
  i=0
  # Iterate down a (possible) chain of symlinks
  while [ -L "$TARGET_FILE" ]; do
      TARGET_FILE=`readlink $TARGET_FILE`
      cd `dirname $TARGET_FILE`
      TARGET_FILE=`basename $TARGET_FILE`
      i=$((i+1))
      if [ "$i" -gt 1000 ]; then  # check for symlink loop
        echo "Probably encountered symlink loops while resolving path" 1>&2 && exit 1
      fi
  done
  echo "$(pwd -P)"/"$TARGET_FILE"
)

shsh_root_prefix="${XDG_DATA_HOME:-$HOME/.local/share}"
export SHSH_ROOT="$shsh_root_prefix/shsh"

export SHSH_PREFIX="${SHSH_PREFIX:=$SHSH_ROOT/cellar}"
export SHSH_PACKAGES_PATH="${SHSH_PACKAGES_PATH:=$SHSH_PREFIX/packages}"
export SHSH_INSTALL_BIN="${SHSH_INSTALL_BIN:=$SHSH_PREFIX/bin}"
export SHSH_INSTALL_MAN="${SHSH_INSTALL_MAN:=$SHSH_PREFIX/man}"
shsh_config_prefix="${XDG_CONFIG_HOME:=$HOME/.config}"
export SHSHRC="${SHSHRC:=$XDG_CONFIG_HOME/shshrc}"

bin_path="$(dirname `resolve_link "$0"`)"
export PATH="${bin_path}:${PATH}"
export UTILS_FUNC="$bin_path/shsh-_utils"

for arg; do
  shift
  case "$arg" in
    --help)
      show_help="true"
      ;;
    --verbose)
      export SHSH_VERBOSE="true"
      ;;
    --version)
      cat << EOF
shsh (shell script handler) v2.2.1

Copyright (c) 2014 Juan Ibiapina, 2020 Tin Lai (@soraxas)
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Written by Tin Lai (@soraxas)
EOF
      exit
      ;;
    *)
      # set back any unused args
      set -- "$@" "$arg"
  esac
done

command="$1"
case "$command" in
--help|"")
  shsh-help
  ;;
* )
  command_path="$(command -v "shsh-$command" || true)"
  if [ -z "$command_path" ]; then
    shsh-help
    exit 1
  fi
  if [ -n "$show_help" ]; then
    shsh-help "$command"
    exit
  fi

  shift 1
  exec "$command_path" "$@"
  ;;
esac
