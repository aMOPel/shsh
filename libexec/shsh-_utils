#!/usr/bin/env sh
#
# Summary: Utilities that are used throughout the project

resolve_link() {
  if type greadlink >/dev/null 2>&1; then
    greadlink -f "$1"
  else
    if ! readlink -f "$1" 2>/dev/null; then
      # use self-implemented `readlink -f`
      readlink_canonicalise "$1"
    fi
  fi
}

readlink_canonicalise() (  # we are using subshell to prevent messing up cd
  # This is poor man's GNU `readlink -f`
  # useful for mac without GNU readlink
  # based on https://stackoverflow.com/questions/1055671/how-can-i-get-the-behavior-of-gnus-readlink-f-on-a-mac
  TARGET_FILE=$1
  cd `dirname $TARGET_FILE`
  TARGET_FILE=`basename $TARGET_FILE`
  i=0
  # Iterate down a (possible) chain of symlinks
  while [ -L "$TARGET_FILE" ]; do
      TARGET_FILE=`readlink $TARGET_FILE`
      cd `dirname $TARGET_FILE`
      TARGET_FILE=`basename $TARGET_FILE`
      i=$((i+1))
      if [ "$i" -gt 1000 ]; then  # check for symlink loop
        echo "Probably encountered symlink loops while resolving path" 1>&2 && exit 1
      fi
  done
  echo "$(pwd -P)"/"$TARGET_FILE"
)

echo_if_verbose() {
  if [ -n "$SHSH_VERBOSE" ]; then
    echo "$1"
  fi
}

remove_linked() {
  # Given a folder as first arg, if anything that follows it
  # is a link resides within the folder, delete it
  package="$1"
  shift
  for link in "$@"; do
    # do nothing if the arugnment is not an actual file
    [ -e "$link" ] || [ -L "$link" ] || continue
    case $(resolve_link "$link") in
      "$package/"*)
        echo_if_verbose "Unlinking $link"
        rm -f "$link"
        ;;
    esac
  done
}

git_check_up_to_date() {
  cd "$1" || exit 1
  git remote update > /dev/null 2>&1
  if git symbolic-ref --short -q HEAD > /dev/null; then
    if [ "$(git rev-list --count "HEAD...HEAD@{upstream}")" -gt 0 ]; then
      return 1
    fi
  fi
}

clear_prev_lines() {
  if [ -n "$SHSH_USE_TPUT" ]; then
    for _ in $(seq 1 "$1"); do
      # go to previous line
      tput cuu 1
      # clear line
      tput el
    done
  else
    for _ in $(seq 1 "$1"); do
      # go to previous line
      printf "\033[1A"
      # clear line
      printf "\033[2K"
    done
  fi
}

update_line() {
  lockfile="$3"
  # given a token of a line, update the line with new content
  awk '$0~v {$0="'"$2"'"} 1' v="$1" \
    "$lockfile" > "${lockfile}.tmp" && mv "${lockfile}.tmp" "${lockfile}"
}
