#!/usr/bin/env sh
#
# Summary: Utilities that are used throughout the project

resolve_link() {
  if type greadlink >/dev/null 2>&1; then
    greadlink -f "$1"
  else
    if ! readlink -f "$1" 2>/dev/null; then
      # use self-implemented `readlink -f`
      readlink_canonicalise "$1"
    fi
  fi
}

readlink_canonicalise() (  # we are using subshell to prevent messing up cd
  # This is poor man's GNU `readlink -f`
  # useful for mac without GNU readlink
  # based on https://stackoverflow.com/questions/1055671/how-can-i-get-the-behavior-of-gnus-readlink-f-on-a-mac
  _target="$(basename "$1")"
  cd "$(dirname "$1")" || exit 1
  i=0
  # Iterate down a (possible) chain of symlinks
  while [ -L "$_target" ]; do
      _target="$(readlink "$_target")"
      cd "$(dirname "$_target")" || exit 1
      _target="$(basename "$_target")"
      i=$((i+1))
      if [ "$i" -gt 1000 ]; then  # check for symlink loop
        echo "Probably encountered symlink loops while resolving path" 1>&2 && exit 1
      fi
  done
  echo "$(pwd -P)"/"$_target"
)

echo_if_verbose() {
  if [ -n "$SHSH_VERBOSE" ]; then
    echo "$1"
  fi
}

remove_linked() {
  # Given a folder as first arg, if anything that follows it
  # is a link resides within the folder, delete it
  _package="$(resolve_link "$1")"
  shift
  for _link; do
    # do nothing if the arugnment is not an actual file
    [ -e "$_link" ] || [ -L "$_link" ] || continue
    case "$(resolve_link "$_link")" in
      "$_package/"*)
        echo_if_verbose "Unlinking $_link"
        rm -f "$_link"
        ;;
    esac
  done
}

add_link() {
  # argunments: src=$1; target=$2
  [ -e "$1" ] || [ -L "$1" ] || return 0

  echo_if_verbose "Linking '$1' to '$2'"
  ln -s "$1" "$2"
}

git_check_up_to_date() {
  cd "$1" || exit 1
  git remote update > /dev/null 2>&1
  if git symbolic-ref --short -q HEAD > /dev/null; then
    if [ "$(git rev-list --count "HEAD...HEAD@{upstream}")" -gt 0 ]; then
      return 1
    fi
  fi
}

clear_prev_lines() {
  if [ -n "$SHSH_USE_TPUT" ]; then
    for _ in $(seq 1 "$1"); do
      # go to previous line
      tput cuu 1
      # clear line
      tput el
    done
  else
    for _ in $(seq 1 "$1"); do
      # go to previous line
      printf "\033[1A"
      # clear line
      printf "\033[2K"
    done
  fi
}

update_line() {
  _lockfile="$3"
  # given a token of a line, update the line with new content
  awk '$0~v {$0="'"$2"'"} 1' v="$1" \
    "$_lockfile" > "${_lockfile}.tmp" && mv "${_lockfile}.tmp" "${_lockfile}"
}

execute_hooks() {
  # $1: user-friendly description
  # $2: target folder
  # $3: the script to execute
  echo "> Executing $1"
  (eval "set -x && cd \"$2\" && $3")
}

check_key_val_pair() {
  # Check if the given argument is in XX=XX format
  case "$1" in (*=*) return 0 ;;esac
  echo "Invalid argunment for flag '$2' with argunment '$1'"
  echo "Must be in the format of $2 <KEY>=<VALUE>"
  exit 1
}

requote_args() {
  # Given a list of args, add quotes if necessary
  C=''
  for i in "$@"; do
    case "$i" in
      *[[:space:]]*)  # contain space
        case "$i" in
          *\'*)  # escape single quote
            i="$(printf "%s" "$i" | sed "s/'/'\"'\"'/g")"
            ;;
          *) : ;;
        esac
        # quote only the parts after equal sign
        # i.e. in the format of pre='echo foo && echo bar'
        case "$i" in
          *=*)  # escape single quote
            i="${i%%=*}='${i#*=}'"
            ;;
          *)  # normal case
            i="'$i'" ;;
        esac ;;
      *) # no space, do nothing
        : ;;
    esac
    if [ -z "$C" ]; then
      C="$i"
    else
      C="$C $i"
    fi
  done
  printf "%s" "$C"
}

prompt ()  {
  while true; do
    printf '%s [y/N]? ' "$1"
    read -r answer
    case $answer in
      y|Y|yes|YES) return 0;;
      ''|n|N|no|NO) return 1;;
      *)
        echo 'Invalid response';
    esac
  done
}

shshrc_get_existing_install_cmd() {
  set +e
  unset existing existing_prefix existing_suffix
  # given $1 as the package name, return the existing line in SHSHRC that installs
  # that package
  if [ -e "$SHSHRC" ]; then
    existing="$(grep -E "^\s*shsh install (.*\s+)?$1(\s.*)?$" "$SHSHRC")"
    # extract suffix if any (e.g. '&& \' or '|| \')
    _ending_pattern='\s+([&][&]|[|][|])\s*[\]\s*$'
    existing_suffix="$(echo "$existing" | grep -oE "$_ending_pattern")"
    # extract prefix if any (i.e. white spaces)
    existing_prefix="$(echo "$existing" | grep -oE "^\s*")"
    # remove these from the statement for comparison
    existing="$(echo "$existing" | sed -E "s/$_ending_pattern//; s/^(\s*)//")"
  fi
  export existing
  export existing_prefix
  export existing_suffix
}